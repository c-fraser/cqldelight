/*
Copyright 2023 c-fraser

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package io.github.cfraser.cqldelight

import com.fasterxml.jackson.databind.PropertyNamingStrategies.UpperSnakeCaseStrategy
import com.squareup.javapoet.FieldSpec
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.TypeSpec
import java.nio.file.Path
import javax.lang.model.element.Modifier
import org.neo4j.cypherdsl.core.renderer.Configuration
import org.neo4j.cypherdsl.core.renderer.Renderer
import org.neo4j.cypherdsl.parser.CypherParser
import org.neo4j.driver.Query
import org.neo4j.driver.Values

/**
 * [QueryGenerator] generates the executable queries, in the [directory], from the parsed
 * statements.
 */
internal class QueryGenerator(private val directory: Path, private val packageName: String) {

  /**
   * Generate a *Java* file containing the executable queries for the [statements], in the
   * [directory], with the [packageName] and [className].
   */
  fun generate(className: String, statements: Sequence<Statement>) {
    val queries = statements.map(::generateQuery)
    val type =
        TypeSpec.classBuilder(className)
            .addJavadoc(
                "Cypher queries generated by <a href=\"https://github.com/c-fraser/cqldelight\">CQLDelight</a>.")
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build())
            .run {
              queries.fold(this) { builder, generated ->
                when (generated) {
                  is Field -> builder.addField(generated.field)
                  is Method -> builder.addField(generated.field).addMethod(generated.method)
                }
              }
            }
            .apply { fieldSpecs.sortBy { it.hasModifier(Modifier.PRIVATE) } }
            .build()
    val file = JavaFile.builder(packageName, type).build()
    file.writeTo(directory)
  }

  private companion object {

    /** The generated declaration(s). */
    sealed interface Generated

    /** A generated field for a [Query] without parameters. */
    @JvmInline value class Field(val field: FieldSpec) : Generated

    /** A generated method for a [Query] with parameters. */
    data class Method(val field: FieldSpec, val method: MethodSpec) : Generated

    /** Generate a [Query] method for the [statement]. */
    fun generateQuery(statement: Statement): Generated {
      val cypher = CypherParser.parse(statement.text)
      val query = renderer.render(cypher)
      val documentation =
          "{@link Query} for the <i>Cypher</i> statement on line ${statement.lineNumber} in {@code ${statement.file}}."
      return if (cypher.parameterNames.isEmpty())
          FieldSpec.builder(Query::class.java, statement.options.queryName.upperSnakeCase())
              .addJavadoc(documentation)
              .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
              .initializer("new \$T(\$S)", Query::class.java, query)
              .build()
              .let(::Field)
      else {
        val field =
            FieldSpec.builder(String::class.java, statement.options.queryName.upperSnakeCase())
                .addJavadoc("<i>Cypher</i> text for {@link #\$L}.", statement.options.queryName)
                .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                .initializer("\$S", query)
                .build()
        Method(
            field,
            MethodSpec.methodBuilder(statement.options.queryName)
                .addJavadoc(documentation)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(Query::class.java)
                .run @Suppress("SpreadOperator") {
                  cypher.parameterNames
                      .fold(this) { builder, name -> builder.addParameter(TypeName.OBJECT, name) }
                      .addStatement(
                          "return new \$T(\$L, \$T.parameters(${cypher.parameterNames.joinToString { "\$S, \$L" }}))",
                          Query::class.java,
                          field.name,
                          Values::class.java,
                          *cypher.parameterNames.flatMap { listOf(it, it) }.toTypedArray())
                }
                .build())
      }
    }

    /** A pretty printing [Renderer]. */
    val renderer: Renderer = Renderer.getRenderer(Configuration.prettyPrinting())

    /** Convert the lower camel case [String] to upper snake case. */
    fun String.upperSnakeCase(): String = UpperSnakeCaseStrategy.INSTANCE.translate(this)
  }
}
